
Minion目前来看就是机器/node

client是一些http api，拿起来使用来访问具体的pod节点的。

目前来看所有的 Registry 接口都是ETCD接口
NewREST 函数创建的都是用来为master作为server用的处理函数
storge是接口，NewREST返回的对象都实现了这个接口，这个接口又是Etcd接口的封装(Registry)

PodCache就是在内存里缓存了PodInfo定时会从etcd拿到所有的pod地址，然后使用http api请求这些pod然后去更新内存cache

总结一下apiserver，其实就是对外提供了几个api接口：
  1.对外提供对object的增删改查
  2.对service的反向代理，代理到了endpoints上
  3.反向代理，可以访问node上的kubelet的接口


/apiserver
   apiserver.go   // 主要函数，用来初始化各种http api
   async.go       // Sync用来执行异步任务
   index.go       //返回 Welcome to Kubernetes字符串、、、就是一个index页面，不用管
   interfaces.go  // ResourceWatcher 用来对外提供一些watch资源的api，看watch.go的注释.  RESTStorage对外剔红操作资源的rest接口，实际就是对etcd操作的封装。 Redirector  对服务的访问可以重定向到某得enpoint
   minionproxy.go // // 这个玩意就是一个反向代理，代理的是node(虚拟机)。如果想通过apiserver向别的node的kubelet获取信息，那么使用这个就行。
   operation.go      // 记录当前正在进行和已经执行完的操作，并对外提供查询操作的http api
   proxy.go          // 目前来看是用来转发请求的，实现了Redirector接口的资源才可以使用这个api，目前来看只有service资源实现了这个接口，。用来把对service的请求反向代理到endpoint
   redirect.go       // 暂时认为和proxy对外提供的接口差不多
   resthandler.go    // 对外提供http api，允许外部对object(runtime.object)进行增删改查，这个是个主要文件，操作资源的
   watch.go          // 对外提供http api， 看起来是用过storge watch函数来watch一些资源，支持的资源有，pod，endpoint，service，controller
/healthz
   healthz.go // 注册的健康检查接口，没啥好看的(目前看是给api server用的)

/registry
   /etcd 这个就是本文件夹下面其他文件夹要用的registry的真正实现
   该文件夹下面的 registry文件定义了对该资源文件操作的接口，这些接口都是etcd实现的，rest.go 文件定义了apiserver给外部提供的对资源进行增删改查的接口，实际操作都是作为registry的etcd接口完成的.

/tools
   etcd_tools.go // etcd工具类
  resthandler.go RESTHandler


replication_controller主要工作
    监听replication的变化，每次有变化就看pod数目满足不满足，如果不满足就掉用apiserver的接口去创建删除
    定时从apiserver拉取所有的replication，查看pod数目满足不满足，如果不满足就掉用apiserver的接口去创建删除
这个东西说白了就是监控pod个数是不是合法，不合法就纠正，所有操作基本都是通过apiserver完成的。

kubecfg主要工作
  1.通过apiserver提供的api对object进行增删改查 2.对controller进行操作，包括修改pod副本数，对controller进行增删改查主要的操作有两个：1.通过apiserver提供的api对object进行增删改查 2.对controller(apiserver 的api)进行操作，包括修改pod副本数，对controller进行增删改查（滚动更新啥的）
kubecfg
├── doc.go
├── kubecfg.go         // 一些实际干活儿的部分，主要的操作有两个：1.通过apiserver提供的api对object进行增删改查 2.对controller进行操作，包括修改pod副本数，对controller进行增删改查
├── parse.go           // 注册了一些runtime.Object类型，用来根据storge创建对应的runtime.Object
├── proxy_server.go    // 代理类，kubecfg可以用代理模式启动，然后作为apiserver的代理
├── resource_printer.go // 一些用来打印runtime.object的工具

Proxy主要工作
   监听service和endpoint的变化，每次有service连接进来的时候根据robin算法选出来一个endpoint，作为他们俩的代理
├── config
│──├── api.go     //监听apiserver，如果有变化通知config.go中定义的接口
│──├── config.go  // 定义了service和endpoint的内存cache，提供接口监听service和endpoint的变化
│──├── doc.go
│──├── etcd.go   // 监听etcd，如果有变化通知config.go中定义的接口
│──└── file.go   // 监听配置文件，如果有变化通知config.go中定义的接口
├── doc.go
├── loadbalancer.go  // 对endpoint进行负载均衡的接口, 有个NextEndpoint函数用来返回下一个要用的endpoint
├── proxier.go   // 真正完成代理工作的类，他会监听service更新，当有service更新时，对该service启动代理。代理工作就是当service有对应的连接进来的时候首先用loadbalancer选出来一个endpoint，然后对这个连接和endpoint做代理
├── roundrobin.go //  负责需在均衡工作，监听endpoint变化，每次调用NextEndpoint使用roundrobin算法取出来一个endpoint


kubelet监听（http/file/etcd）pod变化，根据pod的配置来对本节点的容器进行增删
├── config
│├── config.go // kublete和proxy一样有object的cache只不过它cache的是pod，给外部提供接口，外部监测到pod更新会通知这个cache
│├── doc.go
│├── etcd.go  //  从etcd读取manifest监听pod变化，然后通知config.go
│├── file.go  // 从文件读取manifest监听pod变化，然后通知config.go
│├── http.go  // 通过url读取manifest监听pod变化，然后通知config.go
├── doc.go
├── docker.go  //主要提供了几个接口：1.在指定的容器中执行命令 2.在获取容器信（inspact）3.把image pull下来
├── fake_docker_client.go
├── handlers.go  // 在容器的生命周期中可以回调一些handler，可以是http调用或者在容器里面执行cmd命令
├── kubelet.go   // main函数，主要是监听pod更新，每次监听到pod更新就通过dockerclient对容器进行增删以满足pod的新状态
├── server.go   //对外提供的一些接口，主要可以实现pod更新，也可以对外提供一些信息
├── types.go       // kublete和proxy一样有object的cache只不过它cache的是pod，这个文件记录的就是cache用的一些协议对象。（kublete和proxy 的cache接口长得很像，基本都一样。。）
├── validation.go  // 校验pod是否合法

health
├── exec.go     // 执行CommandRunner，如果没有返回runner，那么就是健康
├── health.go   // 一个health checker的kv集合，key就是http/cmd/tcp value就是定义在http.go/tcp.go/exec.go的checker
├── http.go    // 范围url ，如果url返回的是2xx，那么就说明今健康
├── tcp.go     // connect 指定的ip:port,如果能连接上就说明健康

volume
  |-volume.go // 用来创建volume和清除volume （其实就是创建和删除文件夹）

//scheduler主要是监听有变化的pod，然后根据调度算法调度到对应的队列。调度的原理是写一个pod和节点host的bind到etcd中
scheduler
├── listers.go
├── random.go      // 随机找一个节点调度上去
├── randomfit.go   // 随机找一个端口没有冲突的节点调度上去
├── roundrobin.go // 轮训调度，每次随机选择一个节点把pod调度上去
├── scheduler.go  // 调度接口


plugin/cmd/scheduler
└── scheduler.go

0 directories, 1 file
 ~/go/src/github.com/GoogleCloudPlatform/kubernetes   readv0.2 ●  tree plugin/
plugin/
├── cmd
│ └── scheduler
│    └── scheduler.go  // main函数
└── pkg
    └── scheduler
        ├── factory
        │ ├── factory.go  // 核心文件，监听pod和minio变化，并cache到内存中（pod队列）。
        ├── scheduler.go  // 不断地从pod队列中取得pod，然后根据调度算法调度到对应的队列
